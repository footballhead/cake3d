#pragma once

#include "SceneNode.hpp"
#include "GeometryNode.hpp"
#include <list>
#include <glm/glm.hpp>
#include <map>
#include <string>

// forward declarations
class Model;
class Material;
class Shader;

/**
 * @brief An entity generated by a particle system
 */
class Particle : public GeometryNode {
public:
    /**
     * @brief Create a new particle.
     * @param prim The primitive used to draw the particles.
     * @param mat Visual surface properties.
     * @param shader The shader used the draw the particles.
     * @param vel Initial velocity
     * @param accel Initial acceleration
     * @param life How long the particle stays before fading.
     * @param position Intial position
     * @param scale Model scale.
     */
    Particle( Model * prim, Material * mat, Shader * shader, const glm::vec3 & vel, const glm::vec3 & accel, int life, const glm::vec3 & position, const glm::vec3 & scale );

    ~Particle();

    /**
     * @brief Perform required operations each timestep.
     */
    virtual void update();

    /**
     * @brief Get whether the particle is dead and needs to be removed.
     * @return true if dead, false otherwise.
     */
    bool isDead() const;

private:
    glm::vec3 m_acceleration;
    glm::vec3 m_velocity;
    int m_life;
    /** @brief How much life we initially had (for alpha calc) */
    int m_startLife;
};

#define PSYS_MEAN 0
#define PSYS_VAR 1

/**
 * @brief Contains initialization info for ParticleSystem.
 */
struct ParticleSystemConfig {
    /** @brief Particle model. */
    Model * model;
    /** @brief Particle material. */
    Material * material;
    /** @brief Particle shader. */
    Shader * shader;
    /** @brief Number to generate; 0 is mean, 1 is variance. */
    double number[2];
    /** @brief Particle life; 0 is mean, 1 is variance. */
    int life[2];
    /** @brief Particle initial velocity; 0 is mean, 1 is variance. */
    glm::vec3 velocity[2];
    /** @brief Particle initial acceleration; 0 is mean, 1 is variance. */
    glm::vec3 acceleration[2];
    /** @brief Particle initial position; 0 is mean, 1 is variance. */
    glm::vec3 position[2];
    /** @brief Particle scale; 0 is mean, 1 is variance. */
    glm::vec3 scale[2];
};

/**
 * @brief A particle system is an entity that generates particles each timestep.
 * @details Implementation comes from "Particle Systems -- A Technique for
 *          Modelling a Class of Fuzzy Objects" by Reeves.
 * @remark Particles generated by this system are stored as children of this
 *         node. ONLY PARTICLES MUST BE CHILDREN!
 */
class ParticleSystem : public SceneNode {
public:
    /**
     * @brief Generate a random number between -1 and 1.
     * @returns A random number between -1 and 1.
     */
    static double random();

    /**
     * @brief Get a 3D vector with independent random components.
     * @return glm::vec3( random(), random(), random() )
     */
    static glm::vec3 randomVector();

    static void addConfiguration( std::string name, const ParticleSystemConfig & conf );

    static ParticleSystemConfig getConfiguration( std::string name );

    /**
     * @brief Create a new particle system.
     * @param conf The configuation for the particle system.
     * @parma life Number of timesteps before we stop emitting particles.
     * @remark We use a struct because there's a lot of parameters.
     * @remark A life of 1 means generate only once then never again.
     * @todo TODO No life value for "indefinite"!
     */
    explicit ParticleSystem( const ParticleSystemConfig & conf, int life );

    ~ParticleSystem();

    /**
     * @brief Perform required operations each timestep.
     * @details These operations include creating new particles, assigning those
     *          particles attributes, killing old particles, and transforming
     *          still alive particles.
     */
    virtual void update();

    /**
     * @brief Get whether the particle system is dead.
     * @return true if dead, false otherwise.
     */
    bool isDead() const;

private:
    static std::map<std::string, ParticleSystemConfig> m_config;

    /** @brief Free memory for particles that have expired */
    void removeDeadParticles();

    /** @brief Configuration for generating new particles */
    ParticleSystemConfig m_conf;
    /** @brief Particle system life; different from particle life. */
    int m_life;
};
